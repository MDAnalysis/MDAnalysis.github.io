---
layout: post
title: Introducing Distopia
---

Calculating Euclidian distances under periodic boundary conditions is a core component in both running and analysing  molecular simulations. For example, the calculation of radial distribution functions, hydrogen bonds, structure factors and many other common analyses require calculation of one or more pairwise Euclidian distances. Many molecular mechanics engines have highly optimised code for calculating distances that often make use of specialised code paths and/or accelerators to achieve maximal performance. However this functionality is often
heavily "baked-in" and is not able to be used as a standalone component.

We at MDAnalysis wanted to bring some of this blazing speed to our distance calculations without sacrificing the modularity of MDAnalysis by introducing heavyweight dependencies on a simulation engine. 

## Enter Distopia ##

Instead we developed a lightweight C++ / Python package **distopia** that uses explicit SIMD vectorisation to accelerate calculation of Euclidian distances under periodic boundary conditions. The package is relatively lightweight and aims to provide both a Python and C++ layer to interface with if you would like to quickly
calculate some distances!

## How does distopia compare to existing approaches ##

Currently, many simulation analysis packages offer some kind of compiled layer for 
the numerically intensive job of calculating distances. MDAnalysis currently acheives this with a C header wrapped in Cython. 

Distopia uses **explicit SIMD vectorisation** along with a set of "array of structs" -> "struct of arrays" transforms to get the maximum speed out of the available CPU hardware. 

Lets break down what each of these mean

### Explicit SIMD vectorisation ###

Optimising compilers aim to use the best possible set of CPU instructions, data pipelines and branch predictions to run code as fast as possible. Part of this involves the automatic compilation of code to use  **Single Instruction Multiple Data** instructions that broadcast an operation over multiple data elements using specialised registers. For example, 
a SIMD enabled **add** may be able to work on a 4 32 bit floats at a time using an x86 XMM register introduced with the SSE1 SIMD instruction set. 

The following C++ snippet compiled with `clang 11` using the `-O3` and `march=native` flags shows this nicely. 

```c++
#include <vector>
#include <numeric>

float sum_vector() {
    std::vector<float> vec(16);
    std::iota(vec.begin(), vec.end(), 0);
    float sum = 0;
    for(int i=0; i<vec.size(); i++) {
        sum +=vec[i];
    }
    return sum;

}

```

```assembly
.LCPI0_0:
        .long   0x42f00000                      # float 120
sum_vector():                        # @sum_vector()
        movss   xmm0, dword ptr [rip + .LCPI0_0] # xmm0 = mem[0],zero,zero,zero
        ret
```

However the compiler cannot see all ends and is often incapable of identifying large scale data transformations that may result in better SIMD utilisation down the line.  

## What advantages does Distopia provide ##

 Distopia is fast 


 Distopia is lightweight




 ## Design elements that enable speed ##

 Distopia is  




[Essential Open Source Software for Science]: https://chanzuckerberg.com/eoss/proposals/?cycle=5
